{"version":3,"file":"svg.draw.umd.cjs","sources":["../src/circle.js","../src/ellipse.js","../src/lineable.js","../src/rectable.js","../src/svg.draw.js"],"sourcesContent":["export const circle = {\n  NAME: 'circle',\n\n  init: function () {\n    var p = this.startPoint\n\n    this.el.attr({ cx: p.x, cy: p.y, r: 1 })\n  },\n\n  // We determine the radius by the cursor position\n  calc: function (e) {\n    var p = this.transformPoint(e.clientX, e.clientY)\n    var circle = {\n      cx: this.startPoint.x,\n      cy: this.startPoint.y,\n\n      // calculating the radius\n      r: Math.sqrt(\n        (p.x - this.startPoint.x) * (p.x - this.startPoint.x) + (p.y - this.startPoint.y) * (p.y - this.startPoint.y)\n      ),\n    }\n\n    this.snapToGrid(circle)\n    this.el.attr(circle)\n  },\n}\n","export const ellipse = {\n  NAME: 'ellipse',\n\n  init: function () {\n    // We start with a circle with radius 1 at the position of the cursor\n    var p = this.startPoint\n\n    this.el.attr({ cx: p.x, cy: p.y, rx: 1, ry: 1 })\n  },\n\n  calc: function (e) {\n    var p = this.transformPoint(e.clientX, e.clientY)\n\n    var ellipse = {\n      cx: this.startPoint.x,\n      cy: this.startPoint.y,\n      rx: Math.abs(p.x - this.startPoint.x),\n      ry: Math.abs(p.y - this.startPoint.y),\n    }\n\n    this.snapToGrid(ellipse)\n    this.el.attr(ellipse)\n  },\n}\n","export const lineable = {\n  NAME: 'line polyline polygon',\n\n  init: function () {\n    // When we draw a polygon, we immediately need 2 points.\n    // One start-point and one point at the mouse-position\n\n    this.set = []\n\n    var p = this.startPoint\n    var arr = [\n      [p.x, p.y],\n      [p.x, p.y],\n    ]\n\n    this.el.plot(arr)\n\n    // We draw little circles around each point\n    // This can be disabled by setting { drawCircles: false } option\n    if (this.options.drawCircles) {\n      this.drawCircles()\n    }\n  },\n\n  // The calc-function sets the position of the last point to the mouse-position (with offset ofc)\n  calc: function (e) {\n    var arr = this.el.array().valueOf()\n    arr.pop()\n\n    if (e) {\n      var p = this.transformPoint(e.clientX, e.clientY)\n      arr.push(this.snapToGrid([p.x, p.y]))\n    }\n\n    this.el.plot(arr)\n\n    if (this.options.drawCircles) {\n      this.drawCircles()\n    } else {\n      this.set.forEach((e) => e.remove())\n      this.set = []\n    }\n  },\n\n  point: function (e) {\n    if (this.el.type.indexOf('poly') > -1) {\n      // Add the new Point to the point-array\n      var p = this.transformPoint(e.clientX, e.clientY)\n      var arr = this.el.array().valueOf()\n\n      arr.push(this.snapToGrid([p.x, p.y]))\n\n      this.el.plot(arr)\n\n      if (this.options.drawCircles) {\n        this.drawCircles()\n      }\n\n      // Fire the `drawpoint`-event, which holds the coords of the new Point\n      this.el.fire('drawpoint', { event: e, p: { x: p.x, y: p.y }, m: this.m })\n\n      return\n    }\n\n    // We are done, if the element is no polyline or polygon\n    this.stop(e)\n  },\n\n  clean: function () {\n    // Remove all circles\n    this.set.forEach((e) => e.remove())\n    this.set = []\n    delete this.set\n  },\n\n  drawCircles: function () {\n    var array = this.el.array().valueOf()\n\n    this.set.forEach((e) => e.remove())\n    this.set = []\n\n    for (var i = 0; i < array.length; ++i) {\n      this.p.x = array[i][0]\n      this.p.y = array[i][1]\n\n      var p = this.p.matrixTransform(this.parent.node.getScreenCTM().inverse().multiply(this.el.node.getScreenCTM()))\n\n      this.set.push(this.parent.circle(5).stroke({ width: 1 }).fill('#ccc').center(p.x, p.y))\n    }\n  },\n\n  undo: function () {\n    if (this.set.length) {\n      this.set.splice(-2, 1)[0].remove()\n      this.el.array().splice(-2, 1)\n      this.el.plot(this.el.array())\n      this.el.fire('undopoint')\n    }\n  },\n}\n","export const rectable = {\n  NAME: 'rect image',\n\n  init: function () {\n    var p = this.startPoint\n\n    this.el.attr({ x: p.x, y: p.y, height: 0, width: 0 })\n  },\n\n  calc: function (e) {\n    var rect = {\n      x: this.startPoint.x,\n      y: this.startPoint.y,\n    }\n    var p = this.transformPoint(e.clientX, e.clientY)\n\n    rect.width = p.x - rect.x\n    rect.height = p.y - rect.y\n\n    // Snap the params to the grid we specified\n    this.snapToGrid(rect)\n\n    // When width is less than zero, we have to draw to the left\n    // which means we have to move the start-point to the left\n    if (rect.width < 0) {\n      rect.x = rect.x + rect.width\n      rect.width = -rect.width\n    }\n\n    // ...same with height\n    if (rect.height < 0) {\n      rect.y = rect.y + rect.height\n      rect.height = -rect.height\n    }\n\n    // draw the element\n    this.el.attr(rect)\n  },\n}\n","import { extend, Element, on, off } from '@svgdotjs/svg.js'\nimport { circle } from './circle'\nimport { ellipse } from './ellipse'\nimport { lineable } from './lineable'\nimport { rectable } from './rectable'\n\n// Our Object which manages drawing\nclass PaintHandler {\n  // Default values. Can be changed for the whole project if needed\n  static defaults = {\n    snapToGrid: 1, // Snaps to a grid of `snapToGrid` px\n    drawCircles: true, // Draw little circles around line/polyline/polygon points\n  }\n\n  // Container for all types not specified here\n  static plugins = {}\n\n  constructor(el, event, options) {\n    el.remember('_paintHandler', this)\n    this.el = el\n\n    var _this = this\n    var plugin = this.getPlugin()\n\n    this.parent = el.root()\n    this.p = this.parent.node.createSVGPoint() // Helping point for coord transformation\n    this.m = null // transformation matrix. We get it when drawing starts\n    this.startPoint = null\n    this.lastUpdateCall = null\n    this.options = {}\n    this.set = []\n\n    // Merge options and defaults\n    for (const i in PaintHandler.defaults) {\n      this.options[i] = PaintHandler.defaults[i]\n      if (typeof options[i] !== 'undefined') {\n        this.options[i] = options[i]\n      }\n    }\n\n    if (plugin.point) {\n      plugin.pointPlugin = plugin.point\n      delete plugin.point\n    }\n\n    // Import all methods from plugin into object\n    for (const i in plugin) {\n      this[i] = plugin[i]\n    }\n\n    // When we got an event, we use this for start, otherwise we use the click-event as default\n    if (!event) {\n      this.parent.on('click.draw', function (e) {\n        _this.start(e)\n      })\n    }\n  }\n\n  transformPoint(x, y) {\n    this.p.x = x - (this.offset.x - window.pageXOffset)\n    this.p.y = y - (this.offset.y - window.pageYOffset)\n\n    return this.p.matrixTransform(this.m)\n  }\n\n  start(event) {\n    var _this = this\n\n    // get the current transform matrix from screen to element (offset corrected)\n    this.m = this.el.node.getScreenCTM().inverse()\n\n    // we save the current scrolling-offset here\n    this.offset = { x: window.pageXOffset, y: window.pageYOffset }\n\n    // we want to snap in screen-coords, so we have to scale the snapToGrid accordingly\n    this.options.snapToGrid *= Math.sqrt(this.m.a * this.m.a + this.m.b * this.m.b)\n\n    // save the startpoint\n    this.startPoint = this.snapToGrid(this.transformPoint(event.clientX, event.clientY))\n\n    // the plugin may do some initial work\n    if (this.init) {\n      this.init(event)\n    }\n\n    // Fire our `drawstart`-event. We send the offset-corrected cursor-position along\n    this.el.fire('drawstart', { event: event, p: this.p, m: this.m })\n\n    // We need to bind the update-function to the mousemove event to keep track of the cursor\n    on(window, 'pointermove.draw', function (e) {\n      _this.update(e)\n    })\n\n    // Every consecutive call to start should map to point now\n    this.start = this.point\n  }\n\n  // This function draws a point if the element is a polyline or polygon\n  // Otherwise it will just stop drawing the shape cause we are done\n  point(event) {\n    if (this.point !== this.start) return this.start(event)\n\n    if (this.pointPlugin) {\n      return this.pointPlugin(event)\n    }\n\n    // If this function is not overwritten we just call stop\n    this.stop(event)\n  }\n\n  // The stop-function does the cleanup work\n  stop(event) {\n    if (event) {\n      this.update(event)\n    }\n\n    // Plugin may want to clean something\n    if (this.clean) {\n      this.clean()\n    }\n\n    // Unbind from all events\n    off(window, 'pointermove.draw')\n    this.parent.off('click.draw')\n\n    // remove Refernce to PaintHandler\n    this.el.forget('_paintHandler')\n\n    // overwrite draw-function since we never need it again for this element\n    this.el.draw = function () {}\n\n    // Fire the `drawstop`-event\n    this.el.fire('drawstop')\n  }\n\n  // Updates the element while moving the cursor\n  update(event) {\n    if (!event && this.lastUpdateCall) {\n      event = this.lastUpdateCall\n    }\n\n    this.lastUpdateCall = event\n\n    // Get the current transform matrix\n    // it could have been changed since the start or the last update call\n    this.m = this.el.node.getScreenCTM().inverse()\n\n    // Call the calc-function which calculates the new position and size\n    this.calc(event)\n\n    // Fire the `drawupdate`-event\n    this.el.fire('drawupdate', { event: event, p: this.p, m: this.m })\n  }\n\n  // Called from outside. Finishs a poly-element\n  done() {\n    this.calc()\n    this.stop()\n\n    this.el.fire('drawdone')\n  }\n\n  // Called from outside. Cancels a poly-element\n  cancel() {\n    // stop drawing and remove the element\n    this.stop()\n    this.el.remove()\n\n    this.el.fire('drawcancel')\n  }\n\n  // Calculate the corrected position when using `snapToGrid`\n  snapToGrid(draw) {\n    var temp = null\n\n    // An array was given. Loop through every element\n    if (draw.length) {\n      temp = [draw[0] % this.options.snapToGrid, draw[1] % this.options.snapToGrid]\n      draw[0] -= temp[0] < this.options.snapToGrid / 2 ? temp[0] : temp[0] - this.options.snapToGrid\n      draw[1] -= temp[1] < this.options.snapToGrid / 2 ? temp[1] : temp[1] - this.options.snapToGrid\n      return draw\n    }\n\n    // Properties of element were given. Snap them all\n    for (var i in draw) {\n      temp = draw[i] % this.options.snapToGrid\n      draw[i] -=\n        (temp < this.options.snapToGrid / 2 ? temp : temp - this.options.snapToGrid) +\n        (temp < 0 ? this.options.snapToGrid : 0)\n    }\n\n    return draw\n  }\n\n  param(key, value) {\n    this.options[key] = value === null ? PaintHandler.defaults[key] : value\n\n    this.update()\n  }\n\n  // Returns the plugin\n  getPlugin() {\n    return PaintHandler.plugins[this.el.type]\n  }\n\n  static extend(name, obj) {\n    var plugins = {}\n    if (typeof name === 'string') {\n      plugins[name] = obj\n    } else {\n      plugins = name\n    }\n\n    for (var shapes in plugins) {\n      var shapesArr = shapes.trim().split(/\\s+/)\n\n      for (var i in shapesArr) {\n        PaintHandler.plugins[shapesArr[i]] = plugins[shapes]\n      }\n    }\n  }\n}\n\nextend(Element, {\n  // Draw element with pointer\n  draw: function (event, options, value) {\n    // sort the parameters\n    if (!(event instanceof Event || typeof event === 'string')) {\n      options = event\n      event = null\n    }\n\n    // get the old Handler or create a new one from event and options\n    var paintHandler = this.remember('_paintHandler') || new PaintHandler(this, event, options || {})\n\n    // When we got an event we have to start/continue drawing\n    if (event instanceof Event) {\n      paintHandler.start(event)\n    }\n\n    // if event is located in our PaintHandler we handle it as method\n    if (paintHandler[event]) {\n      paintHandler[event](options, value)\n    }\n\n    return this\n  },\n})\n\nPaintHandler.extend(rectable.NAME, rectable)\nPaintHandler.extend(lineable.NAME, lineable)\nPaintHandler.extend(ellipse.NAME, ellipse)\nPaintHandler.extend(circle.NAME, circle)\n"],"names":["circle","NAME","init","p","this","startPoint","el","attr","cx","x","cy","y","r","calc","e","transformPoint","clientX","clientY","Math","sqrt","snapToGrid","ellipse","rx","ry","abs","lineable","set","arr","plot","options","drawCircles","array","valueOf","pop","push","forEach","remove","point","type","indexOf","fire","event","m","stop","clean","i","length","matrixTransform","parent","node","getScreenCTM","inverse","multiply","stroke","width","fill","center","undo","splice","rectable","height","rect","_PaintHandler","constructor","remember","_this","plugin","getPlugin","root","createSVGPoint","lastUpdateCall","defaults","pointPlugin","on","start","offset","window","pageXOffset","pageYOffset","a","b","update","svg_js","off","forget","draw","done","cancel","temp","param","key","value","plugins","extend","name","obj","shapes","shapesArr","trim","split","__publicField","PaintHandler","Element","Event","paintHandler"],"mappings":"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"}