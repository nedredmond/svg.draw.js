{"version":3,"file":"svg.draw.js","sources":["../src/circle.js","../src/ellipse.js","../src/lineable.js","../src/rectable.js","../src/svg.draw.js"],"sourcesContent":["export const circle = {\n  NAME: 'circle',\n\n  init: function () {\n    var p = this.startPoint\n\n    this.el.attr({ cx: p.x, cy: p.y, r: 1 })\n  },\n\n  // We determine the radius by the cursor position\n  calc: function (e) {\n    var p = this.transformPoint(e.clientX, e.clientY)\n    var circle = {\n      cx: this.startPoint.x,\n      cy: this.startPoint.y,\n\n      // calculating the radius\n      r: Math.sqrt(\n        (p.x - this.startPoint.x) * (p.x - this.startPoint.x) + (p.y - this.startPoint.y) * (p.y - this.startPoint.y)\n      ),\n    }\n\n    this.snapToGrid(circle)\n    this.el.attr(circle)\n  },\n}\n","export const ellipse = {\n  NAME: 'ellipse',\n\n  init: function () {\n    // We start with a circle with radius 1 at the position of the cursor\n    var p = this.startPoint\n\n    this.el.attr({ cx: p.x, cy: p.y, rx: 1, ry: 1 })\n  },\n\n  calc: function (e) {\n    var p = this.transformPoint(e.clientX, e.clientY)\n\n    var ellipse = {\n      cx: this.startPoint.x,\n      cy: this.startPoint.y,\n      rx: Math.abs(p.x - this.startPoint.x),\n      ry: Math.abs(p.y - this.startPoint.y),\n    }\n\n    this.snapToGrid(ellipse)\n    this.el.attr(ellipse)\n  },\n}\n","export const lineable = {\n  NAME: 'line polyline polygon',\n\n  init: function () {\n    // When we draw a polygon, we immediately need 2 points.\n    // One start-point and one point at the mouse-position\n\n    this.set = []\n\n    var p = this.startPoint\n    var arr = [\n      [p.x, p.y],\n      [p.x, p.y],\n    ]\n\n    this.el.plot(arr)\n\n    // We draw little circles around each point\n    // This can be disabled by setting { drawCircles: false } option\n    if (this.options.drawCircles) {\n      this.drawCircles()\n    }\n  },\n\n  // The calc-function sets the position of the last point to the mouse-position (with offset ofc)\n  calc: function (e) {\n    var arr = this.el.array().valueOf()\n    arr.pop()\n\n    if (e) {\n      var p = this.transformPoint(e.clientX, e.clientY)\n      arr.push(this.snapToGrid([p.x, p.y]))\n    }\n\n    this.el.plot(arr)\n\n    if (this.options.drawCircles) {\n      this.drawCircles()\n    } else {\n      this.set.forEach((e) => e.remove())\n      this.set = []\n    }\n  },\n\n  point: function (e) {\n    if (this.el.type.indexOf('poly') > -1) {\n      // Add the new Point to the point-array\n      var p = this.transformPoint(e.clientX, e.clientY)\n      var arr = this.el.array().valueOf()\n\n      arr.push(this.snapToGrid([p.x, p.y]))\n\n      this.el.plot(arr)\n\n      if (this.options.drawCircles) {\n        this.drawCircles()\n      }\n\n      // Fire the `drawpoint`-event, which holds the coords of the new Point\n      this.el.fire('drawpoint', { event: e, p: { x: p.x, y: p.y }, m: this.m })\n\n      return\n    }\n\n    // We are done, if the element is no polyline or polygon\n    this.stop(e)\n  },\n\n  clean: function () {\n    // Remove all circles\n    this.set.forEach((e) => e.remove())\n    this.set = []\n    delete this.set\n  },\n\n  drawCircles: function () {\n    var array = this.el.array().valueOf()\n\n    this.set.forEach((e) => e.remove())\n    this.set = []\n\n    for (var i = 0; i < array.length; ++i) {\n      this.p.x = array[i][0]\n      this.p.y = array[i][1]\n\n      var p = this.p.matrixTransform(this.parent.node.getScreenCTM().inverse().multiply(this.el.node.getScreenCTM()))\n\n      this.set.push(this.parent.circle(5).stroke({ width: 1 }).fill('#ccc').center(p.x, p.y))\n    }\n  },\n\n  undo: function () {\n    if (this.set.length) {\n      this.set.splice(-2, 1)[0].remove()\n      this.el.array().splice(-2, 1)\n      this.el.plot(this.el.array())\n      this.el.fire('undopoint')\n    }\n  },\n}\n","export const rectable = {\n  NAME: 'rect image',\n\n  init: function () {\n    var p = this.startPoint\n\n    this.el.attr({ x: p.x, y: p.y, height: 0, width: 0 })\n  },\n\n  calc: function (e) {\n    var rect = {\n      x: this.startPoint.x,\n      y: this.startPoint.y,\n    }\n    var p = this.transformPoint(e.clientX, e.clientY)\n\n    rect.width = p.x - rect.x\n    rect.height = p.y - rect.y\n\n    // Snap the params to the grid we specified\n    this.snapToGrid(rect)\n\n    // When width is less than zero, we have to draw to the left\n    // which means we have to move the start-point to the left\n    if (rect.width < 0) {\n      rect.x = rect.x + rect.width\n      rect.width = -rect.width\n    }\n\n    // ...same with height\n    if (rect.height < 0) {\n      rect.y = rect.y + rect.height\n      rect.height = -rect.height\n    }\n\n    // draw the element\n    this.el.attr(rect)\n  },\n}\n","import { extend, Element, on, off } from '@svgdotjs/svg.js'\nimport { circle } from './circle'\nimport { ellipse } from './ellipse'\nimport { lineable } from './lineable'\nimport { rectable } from './rectable'\n\n// Our Object which manages drawing\nclass PaintHandler {\n  // Default values. Can be changed for the whole project if needed\n  static defaults = {\n    snapToGrid: 1, // Snaps to a grid of `snapToGrid` px\n    drawCircles: true, // Draw little circles around line/polyline/polygon points\n  }\n\n  // Container for all types not specified here\n  static plugins = {}\n\n  constructor(el, event, options) {\n    el.remember('_paintHandler', this)\n    this.el = el\n\n    var _this = this\n    var plugin = this.getPlugin()\n\n    this.parent = el.root()\n    this.p = this.parent.node.createSVGPoint() // Helping point for coord transformation\n    this.m = null // transformation matrix. We get it when drawing starts\n    this.startPoint = null\n    this.lastUpdateCall = null\n    this.options = {}\n    this.set = []\n\n    // Merge options and defaults\n    for (const i in PaintHandler.defaults) {\n      this.options[i] = PaintHandler.defaults[i]\n      if (typeof options[i] !== 'undefined') {\n        this.options[i] = options[i]\n      }\n    }\n\n    if (plugin.point) {\n      plugin.pointPlugin = plugin.point\n      delete plugin.point\n    }\n\n    // Import all methods from plugin into object\n    for (const i in plugin) {\n      this[i] = plugin[i]\n    }\n\n    // When we got an event, we use this for start, otherwise we use the click-event as default\n    if (!event) {\n      this.parent.on('click.draw', function (e) {\n        _this.start(e)\n      })\n    }\n  }\n\n  transformPoint(x, y) {\n    this.p.x = x - (this.offset.x - window.pageXOffset)\n    this.p.y = y - (this.offset.y - window.pageYOffset)\n\n    return this.p.matrixTransform(this.m)\n  }\n\n  start(event) {\n    var _this = this\n\n    // get the current transform matrix from screen to element (offset corrected)\n    this.m = this.el.node.getScreenCTM().inverse()\n\n    // we save the current scrolling-offset here\n    this.offset = { x: window.pageXOffset, y: window.pageYOffset }\n\n    // we want to snap in screen-coords, so we have to scale the snapToGrid accordingly\n    this.options.snapToGrid *= Math.sqrt(this.m.a * this.m.a + this.m.b * this.m.b)\n\n    // save the startpoint\n    this.startPoint = this.snapToGrid(this.transformPoint(event.clientX, event.clientY))\n\n    // the plugin may do some initial work\n    if (this.init) {\n      this.init(event)\n    }\n\n    // Fire our `drawstart`-event. We send the offset-corrected cursor-position along\n    this.el.fire('drawstart', { event: event, p: this.p, m: this.m })\n\n    // We need to bind the update-function to the mousemove event to keep track of the cursor\n    on(window, 'pointermove.draw', function (e) {\n      _this.update(e)\n    })\n\n    // Every consecutive call to start should map to point now\n    this.start = this.point\n  }\n\n  // This function draws a point if the element is a polyline or polygon\n  // Otherwise it will just stop drawing the shape cause we are done\n  point(event) {\n    if (this.point !== this.start) return this.start(event)\n\n    if (this.pointPlugin) {\n      return this.pointPlugin(event)\n    }\n\n    // If this function is not overwritten we just call stop\n    this.stop(event)\n  }\n\n  // The stop-function does the cleanup work\n  stop(event) {\n    if (event) {\n      this.update(event)\n    }\n\n    // Plugin may want to clean something\n    if (this.clean) {\n      this.clean()\n    }\n\n    // Unbind from all events\n    off(window, 'pointermove.draw')\n    this.parent.off('click.draw')\n\n    // remove Refernce to PaintHandler\n    this.el.forget('_paintHandler')\n\n    // overwrite draw-function since we never need it again for this element\n    this.el.draw = function () {}\n\n    // Fire the `drawstop`-event\n    this.el.fire('drawstop')\n  }\n\n  // Updates the element while moving the cursor\n  update(event) {\n    if (!event && this.lastUpdateCall) {\n      event = this.lastUpdateCall\n    }\n\n    this.lastUpdateCall = event\n\n    // Get the current transform matrix\n    // it could have been changed since the start or the last update call\n    this.m = this.el.node.getScreenCTM().inverse()\n\n    // Call the calc-function which calculates the new position and size\n    this.calc(event)\n\n    // Fire the `drawupdate`-event\n    this.el.fire('drawupdate', { event: event, p: this.p, m: this.m })\n  }\n\n  // Called from outside. Finishs a poly-element\n  done() {\n    this.calc()\n    this.stop()\n\n    this.el.fire('drawdone')\n  }\n\n  // Called from outside. Cancels a poly-element\n  cancel() {\n    // stop drawing and remove the element\n    this.stop()\n    this.el.remove()\n\n    this.el.fire('drawcancel')\n  }\n\n  // Calculate the corrected position when using `snapToGrid`\n  snapToGrid(draw) {\n    var temp = null\n\n    // An array was given. Loop through every element\n    if (draw.length) {\n      temp = [draw[0] % this.options.snapToGrid, draw[1] % this.options.snapToGrid]\n      draw[0] -= temp[0] < this.options.snapToGrid / 2 ? temp[0] : temp[0] - this.options.snapToGrid\n      draw[1] -= temp[1] < this.options.snapToGrid / 2 ? temp[1] : temp[1] - this.options.snapToGrid\n      return draw\n    }\n\n    // Properties of element were given. Snap them all\n    for (var i in draw) {\n      temp = draw[i] % this.options.snapToGrid\n      draw[i] -=\n        (temp < this.options.snapToGrid / 2 ? temp : temp - this.options.snapToGrid) +\n        (temp < 0 ? this.options.snapToGrid : 0)\n    }\n\n    return draw\n  }\n\n  param(key, value) {\n    this.options[key] = value === null ? PaintHandler.defaults[key] : value\n\n    this.update()\n  }\n\n  // Returns the plugin\n  getPlugin() {\n    return PaintHandler.plugins[this.el.type]\n  }\n\n  static extend(name, obj) {\n    var plugins = {}\n    if (typeof name === 'string') {\n      plugins[name] = obj\n    } else {\n      plugins = name\n    }\n\n    for (var shapes in plugins) {\n      var shapesArr = shapes.trim().split(/\\s+/)\n\n      for (var i in shapesArr) {\n        PaintHandler.plugins[shapesArr[i]] = plugins[shapes]\n      }\n    }\n  }\n}\n\nextend(Element, {\n  // Draw element with pointer\n  draw: function (event, options, value) {\n    // sort the parameters\n    if (!(event instanceof Event || typeof event === 'string')) {\n      options = event\n      event = null\n    }\n\n    // get the old Handler or create a new one from event and options\n    var paintHandler = this.remember('_paintHandler') || new PaintHandler(this, event, options || {})\n\n    // When we got an event we have to start/continue drawing\n    if (event instanceof Event) {\n      paintHandler.start(event)\n    }\n\n    // if event is located in our PaintHandler we handle it as method\n    if (paintHandler[event]) {\n      paintHandler[event](options, value)\n    }\n\n    return this\n  },\n})\n\nPaintHandler.extend(rectable.NAME, rectable)\nPaintHandler.extend(lineable.NAME, lineable)\nPaintHandler.extend(ellipse.NAME, ellipse)\nPaintHandler.extend(circle.NAME, circle)\n"],"names":["circle","ellipse","e"],"mappings":"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"}